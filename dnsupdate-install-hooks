#!/bin/sh
# Script to install the required DHCP hook for various known platforms.
# Copyright 2006 Quest Software, see the COPYING file for licencing
# Authors: Ted Percival <ted.percival@quest.com>
#
# (c) 2006 Quest Software, Inc.  All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of Quest Software, Inc. nor the names of its
#    contributors may be used to endorse or promote products derived from
#    this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# The *_vars functions set variables used on the particular platform.
# The *_script functions echo the script used on the particular platform, so
# you probably want to redirect the output somewhere.
set -e

# print command line usage message
usage () {
    cat <<-.
	Usage: $0 [-irq] <platform>

	Options:
	 -i    Installs a DHCP client hook to run dnsupdate on address changes.
	 -r    Removes the last installed hook.
	 -q    Quiet, no informational messages.

	 <platform>    Style of script to install. Must be one of:
	               linux, aix, hpux, or solaris
	               ('linux' tries to detect dhclient or dhcpcd)

	Warning: running this hook installation script more than once
       	may insert multiple dnsupdate hooks, which is probably not
	what you want.
.
}

#-- Write a verbose, error message to stderr and set $ERROR to true
error () {
    echo "Error: $*" >&2
    ERROR=true
}

#-- Write a verbose, informational message to stderr unless QUIET is true
verbose () {
    $QUIET || echo "$*" >&2
}

TMPSUFFIX='.quest-dhclient.tmp'

QUIET=false
ERROR=false
ACTION=
while getopts irq f; do
	case "$f" in
		i) ACTION=inst;;
		r) ACTION=rm;;
		q) QUIET=true;;
		*) error "unknown option '$f'";;
	esac
done

if [ -z "$ACTION" ]; then
	$ERROR || error "One of -i or -r is required"
fi

shift `expr $OPTIND - 1`

if [ $# -ne 1 ]; then
	ERROR=true
fi

if $ERROR; then
	usage >&2
	exit 1
fi

PLATFORM="$1"

cleanup () {
	if [ -n "$TMPFILE" ]; then
		rm -f "$TMPFILE"
	fi
}

trap cleanup 0 1 2


# This function intends to act exactly as 'head --lines=-<number>' does on
# systems with that feature. It prints all but the last <lines> lines of <file>
# Syntax is 'head_minus_lines <lines> <file>' where lines is the number of lines
# to skip and <file> is the file to be processed. No other options are supported
head_minus_lines () {
	if test $# -ne 2 -o ! -f $2; then
		echo 'Bad argument to head_minus_lines()' >&2
		return 1
	fi

	lines=`wc -l $2 | awk '{ print $1 }'`
	lines=`expr $lines - $1`
	head -n $lines $2
}

# Determine what kind of dhcp client program is being used, sets $dhc
# Mostly useful for Linux distros
# Ladies and gentlemen, standards and consistency are a _good_ thing.
# Possible values of $dhc are: dhclient dhcpcd_new dhcpcd_old unknown
probe_dhc () {
	if [ -x /sbin/dhclient ]; then
		dhc=dhclient
	elif [ -x /sbin/dhcpcd ]; then
		if [ -d /etc/sysconfig/network/if-up.d ]; then
			dhc=dhcpcd_new
		else
			dhc=dhcpcd_old
		fi
	else
		error "Unable to determine DHCP client type"
		exit 1
	fi
}

aix_vars () {
	REALFILE=/etc/dhcpcd.ini
	TMPFILE=/etc/dhcpcd.ini$TMPSUFFIX
}

aix_inst () {
	aix_vars
	sed -e '/^updateDNS/s/^/##quest-dnsupdate##/' \
	    < $REALFILE > $TMPFILE
	echo 'updateDNS "/opt/quest/sbin/dnsupdate '\''%.0s%.0s%s%.0s'\''"' \
	    >> $TMPFILE
	cp $TMPFILE $REALFILE
	verbose "Installed dnsupdate hook into $REALFILE"
}

aix_rm () {
	aix_vars
	grep -v '^updateDNS "/opt/quest/sbin/dnsupdate' < $REALFILE | 
	    sed -e 's/^##quest-dnsupdate##//' > $TMPFILE
	cp $TMPFILE $REALFILE
	verbose "Removed dnsupdate hook from $REALFILE"
}


solaris_script () {
	cat <<'.'
# usage: eventhook <interface> <event>
case "$2" in
	BOUND|EXTEND)
		addr=`/sbin/dhcpinfo -i "$1" Yiaddr`
		/opt/quest/sbin/dnsupdate $addr
	;;
esac
.
}

solaris_vars () {
	case `uname -r` in
	    5.[6789])	
	       error "DHCP event hooks only became available in Solaris 10"
	       exit 1
	       ;;
	esac
	HOOKFILE=/etc/dhcp/eventhook
	TMPFILE=${HOOKFILE}${TMPSUFFIX}
}

# Tries to install the output of $1_script (a string without a bang) into
# $HOOKFILE, creating $HOOKFILE and the bang if it doesn't already exist.
# Also uses $TMPFILE to store working data
# The $1 arg should be a platform like 'suse' (to call suse_inst)
try_inst () {
	if test $# -ne 1 -o -z "$TMPFILE" -o -z "$HOOKFILE"; then
		return 1
	fi

	if [ -f $HOOKFILE ]; then
		${1}_script >> $HOOKFILE
	else
		{ echo '#!/bin/sh'; ${1}_script; } > $HOOKFILE
		chmod +x $HOOKFILE
	fi
	verbose "Successfully installed hook into $HOOKFILE"
}

# Tries to remove the output of $1_script from $HOOKFILE (removing $HOOKFILE
# if it is empty).
# Also uses $TMPFILE to store working data
# Usage is like try_inst
try_rm () {
	if test $# -ne 1 -o -z "$TMPFILE" -o -z "$HOOKFILE"; then
		return 1 
	fi

	test -f $HOOKFILE || return 0

	${1}_script > $TMPFILE

	linecount=`wc -l < $TMPFILE`
	if tail -$linecount $HOOKFILE | cmp $TMPFILE - > /dev/null; then
		# Strip the dnsupdate script from the end of the hook file
		cp $HOOKFILE $TMPFILE
		head_minus_lines $linecount $TMPFILE > $HOOKFILE

		# Remove the hook file if it consists only of shell magic
		echo '#!/bin/sh' > $TMPFILE
		if cmp $HOOKFILE $TMPFILE >/dev/null; then
		    rm -f $HOOKFILE
		fi

		verbose "dnsupdate hook removed from $HOOKFILE"
	else
	        error   "Unable to find dnsupdate hook in $HOOKFILE"
		verbose "No changes made to $HOOKFILE"
		verbose "Manual editing of $HOOKFILE may be necessary."
	fi
}

solaris_inst () {
	solaris_vars
	try_inst solaris
}

solaris_rm () {
	solaris_vars
	try_rm solaris
}


hpux_vars () {
	HOOKFILE=/sbin/rc1.d/S321dnsupdate
	TMPFILE=$HOOKFILE$TMPSUFFIX
}

hpux_script () {
	cat <<'.'
if test 0 -ne 0`/usr/sbin/ch_rc -l -p 'DHCP_ENABLE[0]'`
then
	addr=`/usr/sbin/ch_rc -l -p 'IP_ADDRESS[0]'`
	case "$addr" in
		*.*.*.*) /opt/quest/sbin/dnsupdate $addr;;
	esac
fi
.
}

hpux_inst () {
	hpux_vars
	try_inst hpux
}

hpux_rm () {
	hpux_vars
	try_rm hpux
}


# Linux dhclient hook based on dhclient-script(8) manpage
# This function being called dhclient_script is accidental coincidence
dhclient_script () {
	# Hook is sourced (not executed)
	# Return value is to be passed in exit_status var
	cat <<'.'
# This file is sourced by dhclient-script.
# It doesn't matter if there is a bang (#!/bin/sh) above.
case "$reason" in
BOUND|RENEW|REBIND|REBOOT)
	/opt/quest/sbin/dnsupdate "$new_ip_address"
;;
esac
.
}

dhclient_vars () {
	if [ -d /etc/dhcp3/dhclient-exit-hooks.d ]; then
		HOOKFILE=/etc/dhcp3/dhclient-exit-hooks.d/dnsupdate
	else
		HOOKFILE=/etc/dhclient-exit-hooks
	fi
	TMPFILE=$HOOKFILE$TMPSUFFIX
}


# Based on dhcpcd(8) manpage
dhcpcd_old_script () {
	# TODO: The script is called with [ "$3" = '-d' ] for debug mode.
	# dnsupdate should be called with '-v' if that's the case.
	cat <<'.'
. $1
case $2 in
	new)
		/opt/quest/sbin/dnsupdate "$IPADDR"
	;;
esac
.
}

dhcpcd_old_vars () {
	if [ -d /etc/sysconfig/network/scripts ]; then
		HOOKFILE=/etc/sysconfig/network/scripts/dhcpcd-hook
	else
		HOOKFILE=/etc/dhcpc/dhcpcd.exe
	fi
	TMPFILE=$HOOKFILE$TMPSUFFIX
}

dhc_something_inst () {
	probe_dhc
	${dhc}_vars
	try_inst ${dhc}
}

dhc_something_rm () {
	probe_dhc
	${dhc}_vars
	try_rm ${dhc}
}

dhcpcd_new_vars () {
	HOOKFILE=/etc/sysconfig/network/if-up.d/quest-dnsupdate
	TMPFILE=$HOOKFILE$TMPSUFFIX
}

dhcpcd_new_script () {
	cat <<'.'
test -f /etc/sysconfig/network/ifcfg-$1 &&
. /etc/sysconfig/network/ifcfg-$1
test x"$BOOTPROTO" = x"dhcp" || exit 0
. /var/lib/dhcpcd/dhcpcd-$2.info || exit
/opt/quest/sbin/dnsupdate "$IPADDR"
.
}

case $PLATFORM in
	redhat|linux|rpm|suse|deb)
		dhc_something_$ACTION;;
	aix)
		aix_$ACTION;;
	hpux)
		hpux_$ACTION;;
	solaris)
		solaris_$ACTION;;
	*)
		error "Unrecognised platform '$PLATFORM'"
		exit 1;;
esac

exit 0

# Bitter like a lemon.

# vim: ts=4:sw=4:noet
